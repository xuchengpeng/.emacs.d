;;; core-packages.el --- Initialize core packages configurations. -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2018 xuchengpeng
;;
;; Author: xuchengpeng <xucp@outlook.com>
;; URL: https://github.com/xuchengpeng/emacs.d

;; This file is not part of GNU Emacs.

;;; License:

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:
;;
;; Core packages configurations.
;;

;;; Code:

(defvar dotemacs-core-packages '(use-package diminish bind-key)
  "A list of packages that must be installed (and will be auto-installed if
missing) and shouldn't be deleted.")

(defvar dotemacs-packages ()
  "A list of packages to install. Packages are represented by symbols.")

(defvar doteamcs-modules-path-list ()
  "The path to each modules.")

(setq package-user-dir (concat dotemacs-packages-dir "elpa/")
      load-prefer-newer t
      package-enable-at-startup nil)

(defvar-local package-archives-list '(melpa emacs-china tuna custom))
(defun dotemacs-set-package-archives (archives)
  "Switch to specific package ARCHIVES repository."
  (interactive
   (list
    (intern (completing-read "Switch to archives: "
                             package-archives-list))))
  (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                      (not (gnutls-available-p))))
         (proto (if no-ssl "http" "https")))
    (cond
     ((eq archives 'melpa)
      (setq package-archives `(,(cons "gnu"   (concat proto "://elpa.gnu.org/packages/"))
                               ,(cons "melpa" (concat proto "://melpa.org/packages/"))
                               ,(cons "org"   (concat proto "://orgmode.org/elpa/")))))
     ((eq archives 'emacs-china)
      (setq package-archives `(,(cons "gnu"   (concat proto "://elpa.emacs-china.org/gnu/"))
                               ,(cons "melpa" (concat proto "://elpa.emacs-china.org/melpa/"))
                               ,(cons "org"   (concat proto "://elpa.emacs-china.org/org/")))))
     ((eq archives 'tuna)
      (setq package-archives `(,(cons "gnu"   (concat proto "://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/"))
                               ,(cons "melpa" (concat proto "://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"))
                               ,(cons "org"   (concat proto "://mirrors.tuna.tsinghua.edu.cn/elpa/org/")))))
     ((eq archives 'custom)
      (setq package-archives dotemacs-custom-package-archives))
     (t
      (error "Unknown archives: '%s'" archives))))

  (message "Set package archives to '%s'." archives))

(dotemacs-set-package-archives dotemacs-package-archives)

(defun dotemacs-install-packages (packages-list)
  "Install packages defined by PACKAGES-LIST."
  (when-let* ((core-packages (cl-remove-if #'package-installed-p packages-list)))
    (unless package-archive-contents
      (package-refresh-contents))
    (dolist (package core-packages)
      (let ((inhibit-message t))
        (package-install package))
      (if (package-installed-p package)
          (message "dotemacs installed %s" package)
        (error "dotemacs couldn't install %s" package)))))

(defun dotemacs-ensure-packages-initialized ()
  "Make sure package.el is initialized."
    (require 'package)
    (package-initialize))

(defun dotemacs-ensure-core-packages ()
  "Make sure `dotemacs-core-packages' are installed."
  (dotemacs-install-packages dotemacs-core-packages)
  (setq use-package-verbose t))

(defun dotemacs-load-core-autoload ()
  "Load core autoload files."
  (let ((targets
           (file-expand-wildcards
            (expand-file-name "autoload/*.el" dotemacs-core-dir))))
    (dolist (file (reverse targets))
      (load file t t))))

(defun dotemacs-load-modules-autoload ()
  "Load autoload.el and autoload/*.el in each module."
  (dolist (path doteamcs-modules-path-list)
    (let ((auto-dir  (expand-file-name "autoload" path))
          (auto-file (expand-file-name "autoload.el" path)))
      (when (file-exists-p auto-file)
        (load auto-file t t))
      (when (file-directory-p auto-dir)
        (dolist (file (directory-files-recursively auto-dir "\\.el$"))
          (load file t t))))))

(defun dotemacs-load-autoload ()
  "Load `dotemacs-autoload-file' which is generated by dotemacs-generate-autoload-file."
  (if (file-exists-p dotemacs-autoload-file)
      (load dotemacs-autoload-file t t)
    (progn
      (dotemacs-load-core-autoload)
      (dotemacs-load-modules-autoload))))

(defun dotemacs-generate-autoload-file ()
  "Generate the autoloads.el file, specified by `dotemacs-autoload-file'.

It scans and reads core/autoload/*.el, modules/*/*/autoload.el and
modules/*/*/autoload/*.el, and generates an autoloads file at the path specified
by `dotemacs-autoload-file'. This file tells Emacs where to find lazy-loaded
functions.

This should be run whenever init.el or an autoload file is modified."
  (interactive)
  
  (let ((targets
           (file-expand-wildcards
            (expand-file-name "autoload/*.el" dotemacs-core-dir))))
      (dolist (path doteamcs-modules-path-list)
        (let ((auto-dir  (expand-file-name "autoload" path))
              (auto-file (expand-file-name "autoload.el" path)))
          (when (file-exists-p auto-file)
            (push auto-file targets))
          (when (file-directory-p auto-dir)
            (dolist (file (directory-files-recursively auto-dir "\\.el$"))
              (push file targets)))))
      (when (file-exists-p dotemacs-autoload-file)
        (delete-file dotemacs-autoload-file)
        (message "Deleted old autoloads.el"))
      (dolist (file (reverse targets))
        (message
         (cond ((update-file-autoloads file nil dotemacs-autoload-file)
                "Nothing in %s")
               (t
                "Scanned %s"))
         (file-relative-name file dotemacs-dir)))
      (make-directory (file-name-directory dotemacs-autoload-file) t)
      (let ((buf (get-file-buffer dotemacs-autoload-file))
            current-sexp)
        (unwind-protect
            (condition-case-unless-debug ex
                (with-current-buffer buf
                  (save-buffer)
                  (goto-char (point-min))
                  (while (re-search-forward "^(" nil t)
                    (save-excursion
                      (backward-char)
                      (setq current-sexp (read (thing-at-point 'sexp t)))
                      (eval current-sexp t))
                    (forward-char))
                  (message "Finished generating autoloads.el!"))
              ('error
               (delete-file dotemacs-autoload-file)
               (error "Error in autoloads.el: (%s %s ...) %s -- %s"
                      (nth 0 current-sexp)
                      (nth 1 current-sexp)
                      (car ex) (error-message-string ex))))
          (kill-buffer buf)))))

(defun dotemacs-modules-load-package ()
  "Load packages.el in each module."
  (dolist (m-path doteamcs-modules-path-list)
    (let ((path (concat m-path "packages.el")))
      (when (file-exists-p path)
        (load path t t))))
  (dotemacs-install-packages dotemacs-packages))

(defun dotemacs-modules-load-config ()
  "Load config.el in each module."
  (dolist (m-path doteamcs-modules-path-list)
    (let ((path (concat m-path "config.el")))
      (if (file-exists-p path)
          (load path t t)
        (message (format "%s does not exist!" path))))))

(defun dotemacs-initialize-modules ()
  "Initialize modules."
  (dotemacs-modules-load-package)
  (dotemacs-modules-load-config))

(defun dotemacs-keyword-to-name-str (keyword)
  "Remove the colon in KEYWORD symbol and turn it into string.

i.e. :keyword to \"keyword\"."
  (replace-regexp-in-string "^:" "" (symbol-name keyword)))

(defmacro dotemacs! (&rest modules-list)
  "Declare modules in MODULES-LIST.
Separate modules with sub-directories' name.
Basically adding modules path to `doteamcs-modules-path-list'.

Example: (dotemacs! :feature evil :ui custom) for modules/feature/evil
and modules/ui/custom."
  (dolist (module modules-list)
    (cond ((keywordp module) (setq mode module))
          ((not      mode) (error "No sub-folder specified in `dotemacs!' for %s" module))
          (t               (let ((module-path (format "%s%s/%s/" dotemacs-modules-dir (dotemacs-keyword-to-name-str mode) module)))
                             (add-to-list 'doteamcs-modules-path-list module-path t))))))

(defmacro package! (&rest packages-list)
  "Add packages in PACKAGES-LIST to ‘dotemacs-packages’.

Can take multiple packages.
e.g. (package! evil evil-surround)"
  `(dolist (package ',packages-list)
     (add-to-list 'dotemacs-packages package)))

(provide 'core-packages)

;;; core-packages.el ends here
